# C 预处理器与宏

#doing

知识概要：

* 预处理指令：`#define`，`#include`，`#ifdef`，`#else`，`#endif`，`#ifndef`，`#if`，`#elif`，`#line`，`#error`，`#pragma`
* 关键字：`_Generic`，`_Noreturn`，`_Static_assert`
* 函数和宏：`sqrt()`, `atan()`, `atan2()`, `exit()`, `atexit()`, `assert()`, `memcpy()`, `memmove()`, `va_start()`, `va_arg()`, `va_copy()`, `va_end()`
* 通用选择表达式
* 内联函数

## C 预处理器

* 预处理器在什么时候执行？有什么功能？
  * 想一想 `#include, #define, #if`
* 翻译程序的步骤
  * 字符映射【源字符集】【多字节字符和三字节字符】【字符扩展】 #Question
  * 转换**物理行**（反斜杠+换行符）为**逻辑行**
    * 预处理表达式的长度如何？这一步如何为预处理器做准备？
    * 动手写一个两行的 `#define` 指令
  * 划分**预处理记号序列、空白序列、注释序列**
    * 注释被替换为什么？==重要==
    * 空白序列可能被替换为什么？
* 宏是什么？
  * 类对象宏（object-like macro）
  * 类函数宏（function-like macro）
  * 宏的名称规则
  * 宏展开
  * 宏参数
  * 宏调用
    * 传递参数记号
  * **避免在宏中使用递增/递减运算符**
* C中有哪些预定义宏？预定义标识符？
* 预处理器运算符是什么？你能想起几个？【defined(), _Pragma()】
  * 运算符不是宏，所以它可以如何使用？
  * `_Pragma()` 解字符串的操作是什么？


## `#define`

* 预处理器如何识别预处理指令？
* 预处理指令对 `#` 两侧的空格有要求吗？
* 指令的有效区域有多大？

* 指令有哪些部分？

> 多学一些：记号（token）型字符串与字符型字符串
>
> 实际应用中，预处理器可能把替换体视为字符串或记号
>
> 编译器则不关心，它理解C的语法
>
> * 这涉及到了**重定义常量**的内容：记号相同、顺序相同
> * 使用 `const` 和作用域会更简单些

* 宏可以表示哪些东西？
* 哪些地方的宏不能被替换？
* 如何在 `#define` 中使用参数？
* **字符串化**是什么？如何用宏参数创建字符串？
  * 这利用了字符串的串联特性
* **记号粘合剂** `##`怎么使用？
  * 尝试写一个 `PRIN_XN(X)` 宏，能够打印变量 `xX`
* **变参宏**怎么使用？
  * 它在哪个头文件？
  * 尝试写一个 `PR(...)` 宏，它的用法和 `printf()` 类似
* 宏有哪些注意事项？
  * 命名
  * 圆括号

## `#include`

* 两种形式，有什么区别？
* 头文件中常包含哪些内容？【明示常量，宏函数，函数声明，结构模板定义，类型定义】
  * 对应的源文件如何编写？
  * 如何编译多文件？
  * 头文件声明外部变量的方式是什么？

## `#undef`

* C 预处理器怎么判别**已定义**和**未定义**的**标识符**？
  * 不是**宏**的标识符一律判定为未定义
* 哪些宏是不能取消定义的？

## `#ifdef, #ifndef, #else, #endif`

* 较新的编译器可以使用缩进
* 如何使用 `#ifndef` 避免多次包含同一个头文件？
  * 标准头文件：一般使用文件名作为标识符，下划线做前后缀并代替点字符
  * 自己的头文件：不要用下划线前缀

## `#if, #elif, #else, #endif`

* `#if` 后面跟什么表达式？

* 较新的指令可以使用 `#if defined (VAX)`

## `#line, #error`

* `#line` 可以重置哪些预定义宏？
* `#error` 由谁发出？发出什么？一般如何使用？
  * 尝试写一个 `#error` 指令，当编译器不支持 C11 时预编译失败

## `#pragma`



## 内联函数

* 怎么声明一个内联函数？
* 内联函数可以得到地址吗？为什么？能不能在调试器中显示？
* 内联函数的链接是什么类型的？为什么可以在头文件中定义？



> 参考材料：
>
> * 泛型选择（C11）
> * `_Noreturn` 函数