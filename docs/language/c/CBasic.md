---
tags:
    - Ongoin
---

# C è¯­è¨€åŸºç¡€

å› ä¸ºå¤ä¹ æ—¶äº¤å‰é˜…è¯»ä¸­è‹±æ–‡ç‰ˆã€ŠC Primer Plusã€‹ï¼Œå› æ­¤ç¬”è®°ä¸­è‹±æ··æ‚ï¼Œè¯·è§è°…ã€‚

## æ€»ä½“ç»“æ„

ç»“åˆ C Primer Plus å’Œè‡ªå·±çš„è§è§£ï¼Œå¯¹ C è¯­è¨€çš„åŸºç¡€çŸ¥è¯†ä½œå¦‚ä¸‹åˆ†ç±»ï¼š

-   åŸºæœ¬æ¦‚å¿µï¼šC è¯­è¨€æ˜¯ä»€ä¹ˆï¼Ÿç¼–ç¨‹æœºåˆ¶ç­‰ã€‚
-   åŸºç¡€çŸ¥è¯†
    -   æ•°æ®
    -   è¿ç®—ç¬¦å’Œè¡¨è¾¾å¼
    -   å­—ç¬¦ä¸²åŠå…¶æ“ä½œ
    -   å…³é”®å­—
-   æ§åˆ¶è¯­å¥
-   å‡½æ•°
-   æŒ‡é’ˆ
-   å†…å­˜ç®¡ç†
-   æ–‡ä»¶
-   é«˜çº§æ•°æ®è¡¨ç¤º
-   ä½æ“ä½œ
-   é¢„å¤„ç†å™¨
-   C åº“

## åŸºæœ¬æ¦‚å¿µ

-   ä½¿ç”¨ C è¯­è¨€çš„ 7 ä¸ªæ­¥éª¤ï¼š
    -   å®šä¹‰ç¨‹åºç›®æ ‡
    -   è®¾è®¡ç¨‹åº
    -   ç¼–å†™ä»£ç 
    -   ç¼–è¯‘
    -   è¿è¡Œç¨‹åº
    -   æµ‹è¯•å’Œè°ƒè¯•ç¨‹åº
    -   ç»´æŠ¤å’Œä¿®æ”¹ç¨‹åº

<!-- prettier-ignore-start -->
!!! tip 
    
    å¹³å¸¸å†™é¢˜æ—¶æˆ‘ä»¬å¾ˆå¯èƒ½å¹¶ä¸å…³æ³¨è¿™ä¸€æµç¨‹ï¼Œä½†æˆ‘è§‰å¾—è¿™ä¸€æµç¨‹ä»£è¡¨ä¸€ä¸ªè‰¯å¥½çš„ä¹ æƒ¯ï¼šå…ˆå¥½å¥½æ€è€ƒå†è¡ŒåŠ¨ã€‚æˆ‘ä»¬æ€»æ˜¯å–œæ¬¢é‡åˆ°é—®é¢˜ç›´æ¥ç€æ‰‹å†™ä»£ç ï¼Œä½†å¦‚æœèƒ½å…ˆè¿›è¡Œåˆ†æï¼Œç”¨è‡ªç„¶è¯­è¨€/ä¼ªä»£ç è¡¨è¿°å‡ºç¨‹åºçš„æ¡†æ¶ï¼Œå°±èƒ½è®©å†™ä»£ç çš„è¿‡ç¨‹æ›´åŠ æµç•…ã€‚
<!-- prettier-ignore-end -->

-   C è¯­è¨€çš„æ ‡å‡†å’Œå‘å±•ï¼š

    -   _K&R C_ æŒ‡çš„æ˜¯ä¹¦æœ¬ _The C Programming Language_ï¼Œè¢«è®¤ä¸ºæ˜¯ç¬¬ä¸€ç‰ˆçš„ C æ ‡å‡†ã€‚
    -   ç¬¬ä¸€ä¸ª _ANSI/ISO C_ å®šä¹‰äº† C è¯­è¨€å’Œ C æ ‡å‡†åº“ï¼Œæ˜¯æ›´å…¨é¢ã€ä¸¥æ ¼çš„æ ‡å‡†ã€‚
        -   å®ƒçš„æœ€ç»ˆç‰ˆæœ¬æ˜¯ _C89_ã€‚
    -   _C99_ ä¸»è¦åšäº† 3 ä»¶äº‹ï¼šå›½é™…åŒ–ã€å¼¥è¡¥ç¼ºé™·å’Œæé«˜è®¡ç®—å®ç”¨æ€§ã€‚
    -   _C11_ å°šæœªå¾—åˆ°å¹¿æ³›åº”ç”¨ã€‚

-   ç¼–ç¨‹æœºåˆ¶ï¼šä¸ºä»€ä¹ˆè¦ç»è¿‡è¿™äº›ç‰¹æ®Šçš„æ­¥éª¤æ‰èƒ½å¾—åˆ° C ç¨‹åºï¼Ÿ
    -   è¿‡ç¨‹ä¸­æ¶‰åŠçš„æ–‡ä»¶æœ‰ï¼šæºä»£ç æ–‡ä»¶ã€ç›®æ ‡ä»£ç æ–‡ä»¶å’Œå¯æ‰§è¡Œæ–‡ä»¶ã€‚
    -   è¿‡ç¨‹ä¸­æ¶‰åŠçš„å·¥å…·æœ‰ï¼šç¼–è¯‘å™¨å’Œé“¾æ¥å™¨ã€‚
    -   è¿™æ ·åšæ˜¯ä¸ºäº†æ¨¡å—åŒ–ï¼šæ›´æ”¹æŸä¸ªæ¨¡å—æ—¶ï¼Œä¸ç”¨é‡æ–°ç¼–è¯‘å…¶ä»–æ¨¡å—ã€‚

<!-- prettier-ignore-start -->
!!! info
    
    å…³äºç¼–è¯‘çš„è¯¦ç»†ä¿¡æ¯å¯ä»¥å‚è€ƒ [gcc](../../basic/linux/tools/gcc.md)ã€‚é€šå¸¸ä½¿ç”¨çš„ç¼–è¯‘å™¨ç›¸å…³å¥—ä»¶æœ‰ GUNï¼ˆ`gcc`ï¼‰ å’Œ LLVMï¼ˆ`clang`ï¼‰ã€‚
<!-- prettier-ignore-end -->

-   å…³é”®å­—ï¼š[CPP reference](https://en.cppreference.com/w/c/keyword) æä¾›äº† C è¯­è¨€å…³é”®å­—çš„è¡¨å•ã€‚

## æ•°æ®

### åŸºæœ¬æ•°æ®ç±»å‹

ä»¥ä¸‹æ˜¯ C è¯­è¨€ä¸­çš„æ•°æ®ç±»å‹å…³é”®å­—ï¼š

| Keyword  | Keyword     |
| -------- | ----------- |
| int      | double      |
| long     | signed      |
| short    | void        |
| unsigned | \_Bool      |
| char     | \_Complex   |
| float    | \_Imaginary |

<!-- prettier-ignore-start -->
!!! note "è€ƒè€ƒä½ "
    
    * ä»€ä¹ˆæ˜¯ä½ã€å­—èŠ‚å’Œå­—ï¼Ÿ
    * ä½ çŸ¥é“è¿™äº›æ•°æ®ç±»å‹çš„ä½æ¨¡å¼æ˜¯ä»€ä¹ˆå—ï¼Ÿå¸¸è§çš„è¯­è¨€æ•™æéƒ½ä¸ä½œå…·ä½“ä»‹ç»ï¼Œ[è®¡ç®—æœºç§‘å­¦å¯¼è®º](../../books/è®¡ç®—æœºç§‘å­¦å¯¼è®º.md) å’Œ [æ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿ](../../books/æ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿ.md) åšå‡ºäº†è¯¦ç»†çš„è§£é‡Šã€‚
<!-- prettier-ignore-end -->

å¸ƒå°”ç±»å‹ï¼š

-   `_Bool`: C99

<!-- prettier-ignore-start -->
!!! tip "true å’Œ false"
    
    åœ¨ C23 ä¸­ï¼Œå®ƒä»¬ç»ˆäºæˆä¸ºäº†å…³é”®å­—ã€‚
<!-- prettier-ignore-end -->

#### æ•´å‹

<!-- prettier-ignore-start -->
??? tip "å…³äºä¸ƒä¸ƒå…«å…«çš„æ•´æ•°ç±»å‹"
    
    åœ¨ä¸‰ä¸ªä¿®é¥°ç¬¦ `short`ã€`long` å’Œ `unsigned` çš„åŠ æŒä¸‹ï¼ŒC èƒ½è¡¨ç¤ºå„ç§å„æ ·çš„æ•´æ•°ã€‚
    
    * `short` æ˜¯æœ‰ç¬¦å·ç±»å‹ï¼Œå ç”¨ç©ºé—´**å¯èƒ½**æ¯” `int` å°‘ã€‚
    * `long` åŒæ ·æ˜¯æœ‰ç¬¦å·ç±»å‹ï¼Œå ç”¨ç©ºé—´**å¯èƒ½**æ¯” `int` å¤šã€‚
    * `long long` è‡³å°‘å  64 ä½ï¼Œ**å¯èƒ½**æ¯” `long` å¤šã€‚
    
    ä¸ºä»€ä¹ˆè¦æå‡ºè¿™ä¹ˆå¥‡æ€ªçš„ä¸œè¥¿ï¼Ÿå› ä¸º C æ ‡å‡†**åªè§„å®šäº†åŸºæœ¬æ•°æ®çš„æœ€å°å¤§å°**ğŸ˜“ã€‚
<!-- prettier-ignore-end -->

ä»¥ä¸‹æ˜¯æ•´å‹æ•°æ®å¸¸è§çš„å®ç°ï¼š

-   long long: 64 bits
-   long: 32 bits $\in [-2 147 483 648, 2 147 483 647]$
-   short: 16 bits $\in [-32 768, 32767]$
-   int 32 bits or 16 bits (depend on size of word)

Which `int` type to choose?

-   First consider `unsigned` types for **counting**: reach higher positive numbers
-   Save storage

æ•´å‹å­—é¢é‡æ•°æ®æœ‰ä¸€äº›å‰åç¼€ï¼š

-   `0` å…«è¿›åˆ¶
-   `0x` æˆ– `0X` åå…­è¿›åˆ¶
-   `L` long å¸¸é‡
-   `U` unsigned å¸¸é‡

<!-- prettier-ignore-start -->
!!! bug "æ•´æ•°æº¢å‡º"
    
    åœ¨ C è¯­è¨€ä¸­ï¼Œæ•´æ•°æº¢å‡ºæ˜¯æœªå®šä¹‰çš„è¡Œä¸ºã€‚
<!-- prettier-ignore-end -->

<!-- prettier-ignore-start -->
??? info "å¯ç§»æ¤çš„æ•´æ•°ç±»å‹"
    
    è›®å¤æ‚çš„ï¼Œä¸æƒ³å…³å¿ƒè¿™å—å†…å®¹ï¼Œéšæ‰‹è®°ä¸€ä¸‹ã€‚
    
    -   Portable types: `stdint.h`, `inttypes.h`
        -   exact-width integer: `int32_t`
        -   minimum width types: `int_least8_t`
        -   fastest minimum width types: `int_fast8_t`
        -   `intmax_t`
    -   Complex and imaginary Floating Point:
        -   `float _Complex`
        -   `double _Imaginary`
<!-- prettier-ignore-end -->



### å­—ç¬¦

å­—ç¬¦å¸¸é‡æ˜¯ä»¥æ•°å€¼å½¢å¼å­˜å‚¨çš„ï¼Œç¼–è¯‘å™¨ä¼šå°†å­—ç¬¦å¸¸é‡è½¬æ¢ä¸ºæ•°å€¼ï¼Œå¹¶ä¸”è§†ä¸º `int` ç±»å‹ã€‚

<!-- prettier-ignore-start -->
??? tip "ç±³å¥‡å¦™å¦™å±‹"
    
    ä¸Šæ–‡æåˆ°ï¼Œå­—ç¬¦å¸¸é‡è¢«è§†ä¸º `int` ç±»å‹ã€‚é‚£ä¹ˆï¼Œåœ¨ `int` ä¸º 32 ä½çš„ç³»ç»Ÿä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰å­—ç¬¦å¸¸é‡ `FATE`ï¼ŒæŠŠ 4 ä¸ªç‹¬ç«‹çš„ 8 ä½å­—ç¬¦å‚¨å­˜åœ¨ä¸€ä¸ª 32 ä½å­˜å‚¨å•å…ƒä¸­ã€‚ä½†å¦‚æœå°†è¯¥å€¼èµ‹ç»™ `char` ç±»å‹ï¼Œåªæœ‰æœ€å 8 ä½ï¼ˆä½ 8 ä½ï¼‰æœ‰æ•ˆã€‚ç¼–è¯‘å™¨ä¼šä¸ºè¯¥æ“ä½œæŠ›å‡ºè­¦å‘Šã€‚
<!-- prettier-ignore-end -->

ä»¥ä¸‹æ˜¯å€¼å¾—è®°å¿†çš„å­—ç¬¦çš„ ASCII ç ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå¤§å°å†™å­—æ¯ä¹‹é—´çš„é—´è·åªæœ‰ 7ã€‚

| Char | Dec | Hex  |
| ---- | --- | ---- |
| 0    | 48  | 0x30 |
| A    | 65  | 0x41 |
| Z    | 90  | 0x5A |
| a    | 97  | 0x61 |

ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸ç”¨çš„è½¬ä¹‰åºåˆ—ï¼ˆEscape Sequencesï¼‰

| Sequence | Meaning     |
| -------- | ----------- |
| \\a       |             |
| \\b       |             |
| \\r      |             |
| \\t       |             |
| \\\\       | backslash |
| \\\'     |             |
| \\"      |             |
| \\?      |             |
| \\0ooo     | octal       |
| \\xhh     | hexadecimal |

<!-- prettier-ignore-start -->
!!! note "å…«è¿›åˆ¶çš„è¡¨ç¤ºå®¹æ˜“å¼•èµ·å›°æƒ‘"
    
    é‡åˆ°ä¸€äº›å­—ç¬¦ä¸²è€ƒé¢˜ï¼Œå¦‚ `"abc\087"` æ‰“å°çš„ç»“æœæ˜¯ `abc`ã€‚å…«è¿›åˆ¶è½¬ä¹‰åºåˆ—ä»¥ `\0` å¼€å¤´å®¹æ˜“ä¸ç©ºå­—ç¬¦æ··è‚´ï¼Œè¦ç‰¢è®°è¿™ä¸€ç‚¹ã€‚å…«è¿›åˆ¶ ASCII æœ€å¤§åˆ°è¾¾äº† 0177ï¼ˆ127ï¼Œ0x7Fï¼‰ã€‚
<!-- prettier-ignore-end -->

## Format Strings and Formatted IO

-   `strlen()`
-   `const`
-   symbolic constants

### 4.1 Introductory Program

### 4.2 Character Strings: An Introduction

-   `scanf()` stops reading at the first _whitespace(blank, tab, or newline)_
-   `strlen()` gives the length of a string in characters, **NOT includes the `'\0'` (but `sizeof()` includes)**
-   two methods to **handle long `printf()` statements**: **spreads over two lines** or printf one line twice
-   `%zd` for return value of `sizeof` and `strlen()`

### 4.3 Constants and the C Processor

-   symbolic constants:
    -   name tells you more than number
    -   easily change the value in several places
-   `#define`: compile-time substitution, done by **preprocessor** (before compiler)
-   manifest constants (å­—é¢é‡)
-   capitalize constants is a good behaviour, or use prefix `c_` or `k_`
-   round (å››èˆäº”å…¥)
-   `const` : allows you to declare a type
    > see Chapter 12 Storage Classes, Linkage, and Memory Management
    > `enum` in Chapter 14 is also constants
-   `limits.h`
    -   `INT_MAX`
    -   `INT_MIN`
    -   `CHAR_BIT`
    -   `SHRT_MAX`
    -   `UINT_MAX`
    -   `ULLONG_MAX`
    -   ...
-   `float.h`
    -   `FLT_DIG` : minimum number of significant decimal digits for a float
    -   `DBL_DIG`
    -   `FLT_MIN` : minimum value for a positive float retaining full precision
    -   `FLT_EPSILON` : difference between 1.00 and the least float value greater than 1.00

### 4.4 Exploring and Exploiting printf() and scanf()

#### `printf()`

-   **conversion specifications:** specify how the data is to be converted into displayable form
    -   `%%`
    -   `%g`
    -   `%i` = `%d`
-   control-string
-   **conversion specification modifiers**
    -   `digit`: minimum filed width
    -   `.digit`: precision (specially for `%g`, the maximum number of significant digits; `%s`, the maximum number of characters to be printed; `integer`, minimum number to appear)
    -   `h` and `hh`: short, char
    -   `j`: `intmax_t` type...
    -   `l` and `ll`: for long, long long integer
    -   `L`: for long double
    -   `t`: for `ptrdiff_t` value `%td`
    -   `z`: for `size_t` value `%zd` (`sizeof, strlen`)
        -   reason for `z` and `t` is portability: the underlying type for `size_t` vary between machines
-   flags
    -   `-`: left-justified
    -   `+`: signed values displayed with sign
    -   `space` : signed values are displayed with a leading space, negative with a minus
    -   `#`:
        -   for `o` and `x`: print `0x`
        -   for `float` : guarantees a decimal-point is printed
    -   `0` : pad the field width with **leading zero** (ignored with - or precision\[int\])

> How does printf() handle mismatched conversion specifiers?
>
> -   **Passing Arguments:** When the computer puts these values on the **stack**, it is guided by the **types of the variables**, not by the conversion specifiers
> -   But printf() **reads them from the stack** according to the conversion specifiers: the conversion specifiers indicates how many bytes `printf()` should read
> -   usually reads **the first n bytes** in the stack

-   return value of `printf()`: the number of characters it printed; negative value if output error

#### `scanf()`

Simple rules for arguments:

-   basic variable types: precede with `&`, (**include array item `&a[n]`**)
-   string: don't use `&`

About blank skipping:

-   Consecutive conversion specifications: `%d%f%s`, skip over the whitespace **in between, except for `%c`**

-   **conversion specifications:**
    -   float and double are the same
-   **conversion specifications modifiers:**
    -   `*`: suppress assignment

## Arrays and Pointers

### 10.1 Arrays

-   Initialization
    -   _Note:_ Using `const` with Arrays
    -   _Note:_ Storage Class Caveat
    -   Partially initialize an array: the remaining elements are set to 0
    -   **sizeof:** `sizeof array` is the size of the whole array in bytes, `sizeof array[0]` is the size of one element in bytes
-   **Designated Initializers (C99):**

    -   pick and choose which elements are initialized
    -   **subscript**

-   Assigning Array Values
-   **Array Bounds:**

    -   It's your responsibility. **_The compiler isn't required to check for you!_**
    -   One simple habit to develop is to use a symbolic constant in the array declaration and in other places the array size is used.

-   **Specifying an Array Size**: use a _constant integer expression_, **a const value isn't**, and the value must be greater than 0

### 10.2 Multidimensional Arrays

-   Initializing a Two-Dimensional Array
-   More Dimensions

### 10.3 Pointers and Arrays

-   array notation is simply a disguised use of pointers: **the C standard describes array notation in terms of pointers** :`ar[n]` means `*(ar + n)`
-   an array name is also the address of the first element of the array
-   `%p` specifier
-   when you say "add 1 to the pointer," C adds one **storage unit**, and the pointer is increased to the **next element**
-   **_Precedence:_** indirection operator `*` is higher than `+`
-   The compiler produces the same code for either pointer method or array method.

### 10.4 Functions, Arrays, and Pointers

-   Question: array as parameter [stackflow](https://stackoverflow.com/questions/25680014/find-the-size-of-integer-array-received-as-an-argument-to-a-function-in-c)

    -   Explanation: `arr` is identified as an array only in its scope. When you pass `arr` to a function, `arr` is regarded as `int *`
    -   Remember: you can only pass a point but not an array

-   Escape Sequence related to pointers

| Escape Sequence | Meaning                     |
| --------------- | --------------------------- |
| %zd             | sizeof                      |
| %td             | difference between pointers |

-   **NOTICE:** one-past-the-end pointer is not guaranteed to be derefenced
-   **Precedence:** unary operators `*` and `++` have the same precedence but associate **from right to left**

### 10.5 Pointer Operations

-   assignment
-   value finding (dereferencing)
-   taking a pointer address
-   adding an integer to a pointer
-   incrementing a pointer
-   subtracting an integer from a pointer
-   decrementing a pointer
-   differencing
-   comparisons

### 10.6 Protecting Array Contents

-   Using `const` with Formal Parameters
-   More about `const`
    -   When you try to modify an `const` variable, you'll receive a **compile-time** error.
    -   **Pointers to constants** can't be used to change values: `const type * ptc`
        -   but `ptc` itself can be changed
        -   valid to assign the address of either **constant or non-constant** data to `ptc`
    -   **const pointers:** `type * const cp` can be used to change values

### 10.7 Pointers and Multidimensional Arrays

Example:

```
int zippo[4][2];
```

-   In value: `zippo` = `zippo[0]`
    -   **NOTICE:** `zippo[0][0] = *(zippo[0]) = **zippo` is not a pointer. It's a int value.
-   The **size of the referred-to object** differ.
-   `zippo = &zippo[0]`: actually `zippo` is an address of an address
-   `*zippo = zippo[0] = &zippo[0][0]`
-   So: `*(*(zippo + 1) + 2) = zippo[1][2]`
-   **Pointers to Multidimensional Arrays**
    -   `[]` has a higher precedence than `*`
    -   `int (* pz)[2]`: points to **an array of 2 ints**
    -   `int * pax[2]`: **an array** of two pointers-to-int
    -   You can use `pz` as `zippo`: `pz[1][2]`
-   **Pointer Compatibility**
    -   **DONOT** assign non-const to const
    -   **DONOT** assign nested pointer types: const qualifier disregarded, behavior undefined

> #### _C_ const and _C++_ const:
>
> Not identically.
>
> -   C++ allows using a const integer value to _declare an array size_
> -   C++ has _stricter rules_ about _pointer assignments_: you're **NOT** allowed to assign a const pointer to a non-const pointer.

-   **Functions and Multidimensional Arrays**

    -   How to make proper declaration for function arguments in functions that process multidimensional array

-

### 10.9 Compound Literals (C99) å¤åˆå­—é¢é‡

-   **Question:** What's the difference between **symbolic constant** and **literals**
-   Example: `(int []){10, 20}`, `(int [2][3]){{1, 2, 3}, {4, 5, 6}}`
-   identified as an array, translates to the **address of the first element**
-   Typical use: pass information to a function **without having to create an array first**
-   **NOTICE:** providing values that are needed only temporarily, has **block scope**

## Character Strings and String functions

-   functions
    -   gets, gets_s, fgets, puts, fputs
    -   strcat, strncat, strcmp, strncmp, strncpy, strncpy, sprintf, strchr
-   command-line arguments

### 11.1 Representing Strings and String I/O

-   `puts()`: only displays strings, _automatically appends a newline_

Ways to _define strings_:

-   Character String Literals (String Constants)
    -   string literals that are separated by nothing or by whitespace will be _concatenated_
    -   placed in the **static storage class**, stored just once and lasts for **the duration of the program**
    -   the entire quoted phrase acts as a **pointer** to where the string is stored
-   Character String Arrays and Initialization
-   **Nodus: Array vs Pointer**
    -   Array:
        -   the memory for the array is allocated only **after the program begins running**, and the quoted string is **copied into the array**
        -   there are two copies of the string: one is the string literal in static memory, one is the string stored in the array (in dynamic memory)
        -   the array name is an **address constant**
    -   Pointer:
        -   just set aside one more storage location for the pointer
        -   **you should declare is as pointing to `const` data**
        -   The compiler has **the freedom** to store a literal thatâ€™s used more than once in one or more locations.
        -   the part of **memory** used for static data is different from that used for dynamic memory, the memory used for array (compiler even uses a different number of bits to represent the two kinds of memory)
        -   **NOTICE:** In short, donâ€™t use a pointer to a string literal if you plan to alter the string.
    -   Arrays of Character Strings
        -   array of pointers
            -   donâ€™t necessarily have to be stored consecutively in memory
        -   array of arrays
            -   each array has the same length

### 11.2 String Input

1. Creating Space
    1. Donâ€™t expect the computer to count the string length as it is read and then allot space for it.
2. Read Strings: `scanf()`, `gets()`, and `fgets()`

3. `gets()`: read an entire line, discards the newline character
    1. C11 has dropped `gets()` from the standard
4. `char *fgets(char *str, int count, FILE *stream)`
    1. reads the newline
    2. reads up to **n-1** characters or newline
    3. return the same address as the first argument or NULL pointer if _encounters EOF_
    4. **NULL** pointer is guaranteed not to point to valid data, can be represented by **0 and the marco `NULL`**
    5. the presence or absence of a newline character in the stored string can be used to tell **whether the whole line was read**
5. `int fputs(const char *str, FILE *stream)`
    1. doesn't automatically append a newline
    2. **NOTICE: The system uses buffered I/O.** This means the input is stored in temporary memory (the buffer) until the **Return key** is pressed. On output, when a **newline is sent**, the buffer contents are sent on to the display.
6. `gets_s()`: C11's optional function, DO NOT use

7. `scanf()`: starts at the first non-whitespace character, runs up to (_but not including_) the next whitespace character (blank, tab, or newline)

    but you can specify a field width

8.

### 11.3 String Output

### 11.4The Do-It-Yourself Option

### 11.5 String Functions

### 11.6 A String Example: Sorting Strings

### 11.7 The `ctype.h` Character Functions and Strings

### 11.8 Command-Line Arguments

### 11.9 String-to-Number Conversions

## é«˜çº§ä¸»é¢˜

è¿™é‡Œæä¾›äº†é«˜çº§ä¸»é¢˜çš„ç¬”è®°ç´¢å¼•ï¼š

-   [è¿ç®—ç¬¦æ±‡æ€»](Operator.md)
-   [å†…å­˜ç®¡ç†](StorageClasses.md)
-   [æ–‡ä»¶ IO](FileIO.md)
-   [ç»“æ„å’Œæ•°æ®ç±»å‹](Structures.md)
-   [ä½è¿ç®—](BitFiddling.md)
-   [é¢„å¤„ç†å™¨ä¸å®](Macro.md)
-   [é«˜çº§æ•°æ®è¡¨ç¤º](ADT.md)
